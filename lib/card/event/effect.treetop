# card_event_effect_grammar.treetop
# You can use a .tt extension instead if you wish
module Card::Event
	grammar Effect
		include Card::Effect

		rule body
			( effect ) none? empty? dot?
			<ShallowParsedQuery>
		end

		rule effect
			( activation_cost )?
			(
				action once_per_turn? divider? /
				once_per_turn
			)*
			( investment divider? )*
			( leader_condition )*
			(
			  sentence /
			  divider? space? then_clause
		  )+ <ShallowParsedQuery>
		end

		rule investment
			don_investment /
			don_sacrifice /
			rest_card_investment and_clause? trash_investment? /
			trash_investment and_clause? rest_card_investment? /
			life_investment /
			return_card_investment /
			select_card_investment
		end

		rule sentence
			draw_sentence card_hand_condition? /
			draw_sentence and_clause? trash_sentence? /
			look_up_sentence and_clause? return_sentence? /
			look_up_sentence divider play_sentence divider place_remaining_card /
			play_sentence /
			reveal_sentence /
			power_gain_sentence then_clause? life_condition? /
			power_give_sentence /
			cost_gain_sentence /
			cost_reduction_sentence /
			ko_sentence /
			rest_opponent_sentence /
			add_don_sentence /
			reactivate_don_sentence /
			return_sentence /
			restand_sentence /
			cannot_block_sentence attack_condition?
		end

		rule activation_cost
			don_cost space?
		end

		rule rest_card_investment
			may_clause? rest up_to? integer
			your ( card / character or_clause? / event or_clause? / stage or_clause? )+
			space?
		end

		rule life_investment
			may_clause? 'add ' integer card 'from your Life area ' hand
			space?
		end

		rule return_card_investment
			may_clause? return integer character hand
			space?
		end

		rule select_card_investment
			'Select ' up_to integer ( your / opponent )*
			( of_type? leader or_clause? / of_type? character )+
			divider? dot? space?
		end

		rule trash_investment
			may_clause? trash ( this / up_to? integer )
			( card / character or_clause? / event or_clause? / stage or_clause? / of_type )+
			hand?
			space?
		end

		rule add_don_sentence
			('Add ' / 'add ') up_to? integer ( rested / active )? don card
			'from your ' don 'deck' space?
			( 'as active' / 'and rest it' / 'and set it as active')
			dot? space?
		end

		rule draw_sentence
			draw up_to? integer card
			space? dot?
		end

		rule trash_sentence
			may_clause? trash
			up_to? integer
			( card / event or_clause? / stage or_clause? )+ hand?
			space? dot?
		end

	  rule look_up_sentence
	  	('Look at' / 'look at') space? up_to? integer card top_deck
	  	divider?
	  end

		rule cost_reduction_sentence
			give ( up_to? integer )
			opponent character
			integer cost turn space? dot?
		end

		rule cost_gain_sentence
			up_to? integer
			( character )
			gain integer cost turn? space? dot?
		end

	  rule ko_sentence
	  	ko (
				( up_to? integer ) ( opponent / your_opponent )
				( rested / active )?
				( character / stage )
				( cost integer or_less? / power integer or_less? / 'with ' integer power or_less? )?
	  		/ and_clause
	  	)
	  	space? dot?
	  end

		rule power_gain_sentence
			( this / 'that ' / up_to? integer your colored? / up_to? integer opponent / up_to? integer / your of_type or_clause? / of_type )+
			( character / leader or_clause character / leader and_clause character / leader / card ) card? ( cost integer )?
			( 'other than this ' card space?)?
			gain ('an additional ')? integer power
			( 'for every ' integer your rested don card )?
			( battle / turn )?
			space? dot?
		end

		rule power_give_sentence
			give
			( this / up_to? integer opponent / up_to? integer your colored? / up_to? integer )
			( character / leader or_clause character / leader ) ( cost integer )?
			integer power ( battle / turn )?
			space? dot?
		end

		rule rest_opponent_sentence
			rest ( up_to? integer / all)
			( opponent / your )
			( character or_clause? / leader )
			( cost integer or_less? )?
			space? dot?
		end

		rule cannot_block_sentence
			your_opponent 'cannot activate ' ('a' space)? trait
			character? ('that has ' / 'with ')?
			integer? ( or_more / or_less )? power?
			battle
			space? dot?
		end

		rule return_sentence
			( return / place )
			( this / up_to? integer / them / 'the rest ' )
			active?
			( card / character or_clause? / event or_clause? / stage or_clause? )*
			( cost integer or_less? )?
			( hand / top_or_bottom_deck / top_deck / bottom_deck )+
			any_order?
			space? dot? # <ReturnEffect>
		end

		rule restand_sentence
			('Set ' / 'set ') ( up_to? integer )
			your ( character / of_type character card )
			( cost integer or_less? )?
			'as ' active
			space? dot?
		end

		rule add_don_sentence
			('Add ' / 'add ') up_to? integer ( rested / active )? don card
			'from your ' don 'deck' space?
			( 'as active' / 'and rest it' / 'and rest them' / and_clause 'set it as active' / and_clause 'set it as rested' )
			space? dot?
		end

		rule reactivate_don_sentence
			set_clause up_to? integer
			your ( rested? don card )
			'as ' active
			space? dot?
		end

		rule reveal_sentence
			reveal ( this / up_to? integer )
			( card / of_type character / of_type card / sub_type / character or_clause? / event or_clause? / stage or_clause? )+
			( 'other than ' has_name )?
			( cost integer or_less? )?
			( and_clause 'add it ' hand )+
			( divider place_remaining_card )?
		  space? dot? # <RevealEffect>
		end

		rule play_sentence
			play ( this / up_to? integer )
			( has_name / of_type character / character or_clause? / event or_clause? / stage or_clause? )+
			( cost integer or_less? )?
			( hand / trash / top_or_bottom_deck / top_deck / bottom_deck / deck )+
			( divider then_clause shuffle_deck )?
			space? dot? # <PlayEffect>
		end

		rule place_remaining_card
			place 'the rest '
			( bottom_deck / top_deck / top_or_bottom_deck / trash_pile )
			any_order?
			space? dot?
		end

		rule leader_condition
			if_clause (your / opponent) leader
			( 'has the ' of_type )
			divider space? # <LeaderCondition>
		end

		rule attack_condition
			if_clause ( 'that ' leader or_clause? / character )+
			'attacks ' turn
			divider? space?
		end

		rule card_hand_condition
			if_clause (you_have / your_opponent_has)
			integer (up_to / or_less)? card hand?
			divider? space? dot? # <CardHandCondition>
		end

		rule life_condition
			if_clause (you_have / your_opponent_has) integer (up_to / or_less)? space? life
			divider space? dot? # <LifeCondition>
		end
	end
end
